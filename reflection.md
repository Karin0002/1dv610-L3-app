# Reflektion inlämning L3

## Kapitel 2, Meaningful Names
Kapitel 2 har påverkat min kod relativt mycket. En del var att jag tidigare hade namngivningen Triadic för alla färg-tema klasser, dvs enbart namnet på temat. Nu har jag döpt om dessa till TriadicThemeFactory. Detta följer nu bättre 'Use Intention-Revealing Names' och 'Use Solution Domain Names'. Jag har även döpt om CSSColorSetter till ColorStyles. Dels behövde jag ändar functionalitet i klassen och det nya namnet matchar bättre dess functionalitet samtidigt som det följer 'Dont Add Gratuitous Context'. Att namnet förut började på CSS gjorde att IDE:n hade väldigt svårt att underlätta för användaren eftersom klassen försvann bland alla default CSS klasser och metoder.

## Kapitel 3, Functions
Den största påverkan som detta kapitel hade var att ändra koden så regeln 'One Level of Abstraction per Function' följdes. Detta syns huvudsakligen i -ThemeFactory klasserna. Tidigare var dessa klasser ganska tunga och mycket kod upprepades i varje klass. Jag kunde inte generalisera särskilt mycket i dom eftersom gemensam kod var blandad med klass-specifik kod. Efter att ha extraherat metoder från dom befintliga så att varje metod enbart hade en abstraktionsnivå kunde jag även generalisera stora delar av beteenden i dom. Denna commit visar hur klassen såg ut innan refactoring https://github.com/Karin0002/1dv610-L2-module-ts/blob/4323d817130f8baff33c6c991c9e911410042143/src/classes/Triadic.ts. Alla färg-tema klasser såg ungefär så ut. Efter ändringarna ser den nu ut såhär https://github.com/Karin0002/1dv610-L2-module-ts/blob/6a5f423bef02772f7cbac6891dd8c062120373da/src/classes/TriadicThemeFactory.ts. Stora delar av logiken har flyttats till föräldraklasser och varje färgtema klass är nu mer åtskiljda. Reglerna 'Small' och 'Do One Thing' blev bättre följda efter refactoring och skedde lite av automatik av att följa regeln 'One Level of Abstraction per Function'.

## Kapitel 4, Comments
Detta kapitel har inte påverkat jättemycket min kod. Innan ändringarna så hade jag xDocs kommentarer på alla metoder som ingick i det publika gränssnittet. Nu har jag tagit bort ett par av dessa som enbart var 'Noise Comments', kommentarer som enbart "restated" exakt vad som kunde läsas från signaturen, tex. Color.hue behöver ingen kommentar som säger att det är hue som returneras. Fortfarande har jag ett par kommentarer som är 'Clarification' tex "const increments = numberOfColors - 1 // 1 since the number of increments is one less than number of colors." i MonochromeThemeFactory.

## Kapitel 5, Formatting
Detta kapitel har heller inte påverkat koden så mycket. Detta är för att jag redan utnyttjade tex 'Vertical Distance', 'Vertical Openness Between Concepts' och 'Vertical Density'. Små förändringar har gjort för att förmedla tillhörighet, t.ex. hade jag tidigare whitespace mellan varje medlemsvariabel https://github.com/Karin0002/1dv610-L2-module-ts/blob/dd1bd339ba72a408add2a09ce39e321a40ab3407/src/classes/Color.ts. Nu har jag istället grupperat medlemsvariabler som hör samman och har enbart whitespace mellan variabler som inte hör samman https://github.com/Karin0002/1dv610-L2-module-ts/blob/abb5962dc2ad5b28d15f0e1af06ed1ca5d91ebfc/src/classes/Color.ts. Jag har ändrat lite i horisontella formateringen genom att korta ned vissa rader genom att dela upp det i variabler. Samtidigt vet jag skiljer mig lite från vissa regler gällande horisontell formatering. Jag har tex alltid ws mellan metodnamn, argument och returtyper. Detta har jag för readability. Utan det har åtminstone jag väldigt svårt att läsa kod. 

## Kapitel 6, Objects and Data Structures
Detta kapitel kunde jag förstå i teorin men i praktiken har jag lite svårt att se var gränsen går mellan ett objekt och en data struktur. I min kod har jag ett antal data strukturer som Style eller MaxMinObjects. Dessa tycker jag är tydliga data strukturer eftersom dom har inget att "gömma". Alla -ThemeFactory klasser tycker jag är tydliga objekt eftersom dom har abstraherat bort stora delar av "inner workings". 'Law of Demeter' tycker jag att jag har följt men samtidigt har det inte varit ett så stort problem eftersom klasserna är ganska oberoende av varandra. 

## Kapitel 7, Error Handling
Även detta kapitel har inte påverkat min kod särskilt mycket. Redan från början så använde jag Error istället för null och "return codes". Jag har inte skapat egna Error-klasser eftersom jag inte tycker att det hade varit mer hjälpsamt för användaren (caller) i dom flesta lägen. 'Provide Context with Exceptions' tycker jag också att jag gjorde från början genom att alltid använda mig av error-messages. 

## Kapitel 8, Boundaries
Detta kapitel tycker jag inte har varit särskilt aktuellt för min applikation. Jag har inga direkta beroende till tredje-parts kod och jag är enda författaren till applikationen. Därför har jag inte direkt haft några boundaries att förhålla mig till. 

## Kapitel 9, Unit Tests
Jag tycker att jag någorlunda har följt reglerna i kapitel 9. Jag har arbetat utifrån 'Single Concept per Test' snarare än 'One Assert per Test'. Så i flertalet tester har jag flera asserts men dom testar samma idé eller koncept, t.ex. invalid argument. (Med den kunskap jag hitills fått från 1dv609 så finns det flera saker som jag skulle ändra om jag skulle skriva om testerna nu, t.ex. parameterized tests (vilket skulle minska antalet asserts per test) och namngivning av test och variabler. Jag skulle även troligen ha följt 'Domain-Specific Testing Language' mer genom att skapa hjälp-metoder och klasser till testerna).